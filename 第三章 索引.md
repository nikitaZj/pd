
<center><h1>第三章 索引</h1></center>


```python
import numpy as np
import pandas as pd
```

## 一、索引器
### 1. 表的列索引
列索引是最常见的索引形式，一般通过`[]`来实现。通过`[列名]`可以从`DataFrame`中取出相应的列，返回值为`Series`，例如从表中取出姓名一列：


```python
df = pd.read_csv('../data/learn_pandas.csv', usecols = ['School', 'Grade', 'Name', 'Gender', 'Weight', 'Transfer'])
df['Name'].head()
```




    0      Gaopeng Yang
    1    Changqiang You
    2           Mei Sun
    3      Xiaojuan Sun
    4       Gaojuan You
    Name: Name, dtype: object



如果要取出多个列，则可以通过`[列名组成的列表]`，其返回值为一个`DataFrame`，例如从表中取出性别和姓名两列：


```python
df[['Gender', 'Name']].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Gender</th>
      <th>Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Female</td>
      <td>Gaopeng Yang</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Male</td>
      <td>Changqiang You</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Male</td>
      <td>Mei Sun</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Female</td>
      <td>Xiaojuan Sun</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Male</td>
      <td>Gaojuan You</td>
    </tr>
  </tbody>
</table>
</div>



此外，若要取出单列，且列名中不包含空格，则可以用`.列名`取出，这和`[列名]`是等价的：


```python
df.Name.head()
```




    0      Gaopeng Yang
    1    Changqiang You
    2           Mei Sun
    3      Xiaojuan Sun
    4       Gaojuan You
    Name: Name, dtype: object



### 2. 序列的行索引

【a】以字符串为索引的`Series`

如果取出单个索引的对应元素，则可以使用`[item]`，若`Series`只有单个值对应，则返回这个标量值，如果有多个值对应，则返回一个`Series`：


```python
s = pd.Series([1, 2, 3, 4, 5, 6], index=['a', 'b', 'a', 'a', 'a', 'c'])
s['a']
```




    a    1
    a    3
    a    4
    a    5
    dtype: int64




```python
s['b']
```




    2



如果取出多个索引的对应元素，则可以使用`[items的列表]`：


```python
s[['c', 'b']]
```




    c    6
    b    2
    dtype: int64



如果想要取出某两个索引之间的元素，并且这两个索引是在整个索引中唯一出现，则可以使用切片,，同时需要注意这里的切片会包含两个端点：


```python
s['c': 'b': -2]
```




    c    6
    a    4
    b    2
    dtype: int64




```python
s['c':'b':-1]
```




    c    6
    a    5
    a    4
    a    3
    b    2
    dtype: int64



【b】以整数为索引的`Series`

在使用数据的读入函数时，如果不特别指定所对应的列作为索引，那么会生成从0开始的整数索引作为默认索引。当然，任意一组符合长度要求的整数都可以作为索引。

和字符串一样，如果使用`[int]`或`[int_list]`，则可以取出对应索引**元素**的值：


```python
s = pd.Series(['a', 'b', 'c', 'd', 'e', 'f'], index=[1, 3, 1, 2, 5, 4])
s[1]
```




    1    a
    1    c
    dtype: object




```python
s[[2,3]]
```




    2    d
    3    b
    dtype: object



如果使用整数切片，则会取出对应索引**位置**的值，注意这里的整数切片同`Python`中的切片一样不包含右端点：


```python
s[1:-1:2]
```




    3    b
    2    d
    dtype: object



以字符串为索引的`Series` vs 以整数为索引的`Series`

    同：使用`[int]`或`[int_list]`，则可以取出对应索引**元素**的值
    异：使用整数切片，则会取出对应索引**位置**的值（！不包含右端点）；
        使用字符串切片会包含两个端点

#### 【WARNING】关于索引类型的说明

如果不想陷入麻烦，那么请不要把纯浮点以及任何混合类型（字符串、整数、浮点类型等的混合）作为索引，否则可能会在具体的操作时报错或者返回非预期的结果，并且在实际的数据分析中也不存在这样做的动机。

#### 【END】

### 3. loc索引器

前面讲到了对`DataFrame`的列进行选取，下面要讨论其行的选取。对于表而言，有两种索引器，一种是基于**元素**的`loc`索引器，另一种是基于**位置**的`iloc`索引器。

`loc`索引器的一般形式是`loc[*, *]`，其中第一个`*`代表行的选择，第二个`*`代表列的选择，如果省略第二个位置写作`loc[*]`，这个`*`是指行的筛选。其中，`*`的位置一共有五类合法对象，分别是：单个元素、元素列表、元素切片、布尔列表以及函数，下面将依次说明。

为了演示相应操作，先利用`set_index`方法把`Name`列设为索引，关于该函数的其他用法将在多级索引一章介绍。


```python
df_demo = df.set_index('Name')
df_demo.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



【a】`*`为单个元素

此时，直接取出相应的行或列，如果该元素在索引中重复则结果为`DataFrame`，否则为`Series`：


```python
df_demo.loc['Qiang Sun'] # 多个人叫此名字
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>53.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Sophomore</td>
      <td>Female</td>
      <td>40.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_demo.loc['Quan Zhao'] # 名字唯一
```




    School      Shanghai Jiao Tong University
    Grade                              Junior
    Gender                             Female
    Weight                                 53
    Transfer                                N
    Name: Quan Zhao, dtype: object



也可以同时选择行和列：


```python
df_demo.loc['Qiang Sun', 'School'] # 返回Series
```




    Name
    Qiang Sun              Tsinghua University
    Qiang Sun              Tsinghua University
    Qiang Sun    Shanghai Jiao Tong University
    Name: School, dtype: object




```python
df_demo.loc['Quan Zhao', 'School'] # 返回单个元素
```




    'Shanghai Jiao Tong University'



【b】`*`为元素列表

此时，取出列表中所有元素值对应的行或列：


```python
df_demo.loc[['Qiang Sun','Quan Zhao'], ['School','Gender']]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Gender</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Tsinghua University</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Qiang Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Quan Zhao</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Female</td>
    </tr>
  </tbody>
</table>
</div>



【c】`*`为切片

之前的`Series`使用字符串索引时提到，如果是唯一值的起点和终点字符，那么就可以使用切片，并且包含两个端点，如果不唯一则报错：


```python
df_demo.loc['Gaojuan You':'Gaoqiang Qian', 'School':'Gender']
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
    </tr>
    <tr>
      <th>Gaoqiang Qian</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
    </tr>
  </tbody>
</table>
</div>



需要注意的是，如果`DataFrame`使用整数索引，其使用整数切片的时候和上面字符串索引的要求一致，都是**元素**切片，包含端点且起点、终点不允许有重复值。


```python
df_loc_slice_demo = df_demo.copy()
df_loc_slice_demo.index = range(df_demo.shape[0],0,-1) # 令表中记录逆序排列
df_loc_slice_demo.loc[5:3]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>5</th>
      <td>Fudan University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Female</td>
      <td>45.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_loc_slice_demo.loc[3:5] # 没有返回，说明不是整数位置切片
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>



【d】`*`为布尔列表

在实际的数据处理中，根据条件来筛选行是极其常见的，此处传入`loc`的布尔列表与`DataFrame`长度相同，且列表为`True`的位置所对应的行会被选中，`False`则会被剔除。

例如，选出体重超过70kg的学生：


```python
df_demo.loc[df_demo.Weight>70].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaopeng Zhou</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaofeng Sun</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>71.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Zheng</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



前面所提到的传入元素列表，也可以通过`isin`方法返回的布尔列表等价写出，例如选出所有大一和大四的同学信息：


```python
df_demo.loc[df_demo.Grade.isin(['Freshman', 'Senior'])].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>51.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



对于复合条件而言，可以用`|（或）, &（且）, ~（取反）`的组合来实现，例如选出复旦大学中体重超过70kg的大四学生，或者北大男生中体重超过80kg的非大四的学生：


```python
condition_1_1 = df_demo.School == 'Fudan University'
condition_1_2 = df_demo.Grade == 'Senior'
condition_1_3 = df_demo.Weight > 70
condition_1 = condition_1_1 & condition_1_2 & condition_1_3
condition_2_1 = df_demo.School == 'Peking University'
condition_2_2 = df_demo.Grade == 'Senior'
condition_2_3 = df_demo.Weight > 80
condition_2 = condition_2_1 & (~condition_2_2) & condition_2_3
df_demo.loc[condition_1 | condition_2]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Han</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Zhou</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changpeng Zhao</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>83.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Qian</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



#### 【练一练】

`select_dtypes`是一个实用函数，它能够从表中选出相应类型的列，若要选出所有数值型的列，只需使用`.select_dtypes('number')`，请利用布尔列表选择的方法结合`DataFrame`的`dtypes`属性在`learn_pandas`数据集上实现这个功能。

#### 【END】


```python
learn_pandas = pd.read_csv('..\data\learn_pandas.csv')
# learn_pandas.head()
# learn_pandas.select_dtypes('number')
learn_pandas.loc[:,learn_pandas.dtypes.isin(['float64','int64'])].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Height</th>
      <th>Weight</th>
      <th>Test_Number</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>158.9</td>
      <td>46.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>166.5</td>
      <td>70.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>188.9</td>
      <td>89.0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>41.0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>4</th>
      <td>174.0</td>
      <td>74.0</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



【e】`*`为函数

这里的函数，必须以前面的四种合法形式之一为返回值，并且函数的输入值为`DataFrame`本身。假设仍然是上述复合条件筛选的例子，可以把逻辑写入一个函数中再返回，需要注意的是函数的形式参数`x`本质上即为`df_demo`：


```python
def condition(x):
    condition_1_1 = x.School == 'Fudan University'
    condition_1_2 = x.Grade == 'Senior'
    condition_1_3 = x.Weight > 70
    condition_1 = condition_1_1 & condition_1_2 & condition_1_3
    condition_2_1 = x.School == 'Peking University'
    condition_2_2 = x.Grade == 'Senior'
    condition_2_3 = x.Weight > 80
    condition_2 = condition_2_1 & (~condition_2_2) & condition_2_3
    result = condition_1 | condition_2
    return result
df_demo.loc[condition]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Qiang Han</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Zhou</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Changpeng Zhao</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>83.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Qian</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



此外，还支持使用`lambda`表达式，其返回值也同样必须是先前提到的四种形式之一：


```python
df_demo.loc[lambda x:'Quan Zhao', lambda x:'Gender']
```




    'Female'



由于函数无法返回如`start: end: step`的切片形式，故返回切片时要用`slice`对象进行包装：


```python
df_demo.loc[lambda x: slice('Gaojuan You', 'Gaoqiang Qian')]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaojuan You</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaoli Qian</th>
      <td>Tsinghua University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>51.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Chu</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Female</td>
      <td>52.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Gaoqiang Qian</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



最后需要指出的是，对于`Series`也可以使用`loc`索引，其遵循的原则与`DataFrame`中用于行筛选的`loc[*]`完全一致，此处不再赘述。

#### 【WARNING】不要使用链式赋值

在对表或者序列赋值时，应当在使用一层索引器后直接进行赋值操作，这样做是由于进行多次索引后赋值是赋在临时返回的`copy`副本上的，而没有真正修改元素从而报出`SettingWithCopyWarning`警告。例如，下面给出的例子：


```python
df_chain = pd.DataFrame([[0,0],[1,0],[-1,0]], columns=list('AB'))
df_chain
import warnings
with warnings.catch_warnings():
    warnings.filterwarnings('error')
    try:
        df_chain[df_chain.A!=0].B = 1 # 使用方括号列索引后，再使用点的列索引
    except Warning as w:
        Warning_Msg = w
print(Warning_Msg)
df_chain
```

    
    A value is trying to be set on a copy of a slice from a DataFrame.
    Try using .loc[row_indexer,col_indexer] = value instead
    
    See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
    




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_chain.loc[df_chain.A!=0,'B'] = 1
df_chain
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



#### 【END】

### 4. iloc索引器

`iloc`的使用与`loc`完全类似，只不过是针对位置进行筛选，在相应的`*`位置处一共也有五类合法对象，分别是：整数、整数列表、整数切片、布尔列表以及函数，函数的返回值必须是前面的四类合法对象中的一个，其输入同样也为`DataFrame`本身。



```python
df_demo.iloc[1, 1] # 第二行第二列
```




    'Freshman'




```python
df_demo.iloc[[0, 1], [0, 1]] # 前两行前两列
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Gaopeng Yang</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
    </tr>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_demo.iloc[1: 4, 2:4] # 切片不包含结束端点
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Gender</th>
      <th>Weight</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Changqiang You</th>
      <td>Male</td>
      <td>70.0</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Male</td>
      <td>89.0</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>Female</td>
      <td>41.0</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_demo.iloc[lambda x: slice(1, 4)] # 传入切片为返回值的函数
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Changqiang You</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Xiaojuan Sun</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



在使用布尔列表的时候要特别注意，不能传入`Series`而必须传入序列的`values`，否则会报错。因此，在使用布尔筛选的时候还是应当优先考虑`loc`的方式。

例如，选出体重超过80kg的学生：


```python
# df_demo.loc[df_demo.Weight>80].head()
df_demo.iloc[(df_demo.Weight>80).values].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>Name</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Mei Sun</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Zheng</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Qiang Han</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Chengpeng Zhou</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Feng Han</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Sophomore</td>
      <td>Male</td>
      <td>82.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



对`Series`而言同样也可以通过`iloc`返回相应位置的值或子序列：


```python
df_demo.School.iloc[1]
```




    'Peking University'




```python
df_demo.School.iloc[1:5:2]
```




    Name
    Changqiang You    Peking University
    Xiaojuan Sun       Fudan University
    Name: School, dtype: object



### 5. query方法

在`pandas`中，支持把字符串形式的查询表达式传入`query`方法来查询数据，其表达式的执行结果必须返回布尔列表。在进行复杂索引时，由于这种检索方式无需像普通方法一样重复使用`DataFrame`的名字来引用列名，一般而言会使代码长度在不降低可读性的前提下有所减少。

例如，将`loc`一节中的复合条件查询例子可以如下改写：


```python
df.query('((School == "Fudan University")&'
         ' (Grade == "Senior")&'
         ' (Weight > 70))|'
         '((School == "Peking University")&'
         ' (Grade != "Senior")&'
         ' (Weight > 80))')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>38</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Qiang Han</td>
      <td>Male</td>
      <td>87.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>66</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>99</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Changpeng Zhao</td>
      <td>Male</td>
      <td>83.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>131</th>
      <td>Fudan University</td>
      <td>Senior</td>
      <td>Chengpeng Qian</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



在`query`表达式中，帮用户注册了所有来自`DataFrame`的列名，所有属于该`Series`的方法都可以被调用，和正常的函数调用并没有区别，例如查询体重超过均值的学生：


```python
df.query('Weight > Weight.mean()').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Gaojuan You</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Xiaopeng Zhou</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>14</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Xiaomei Zhou</td>
      <td>Female</td>
      <td>57.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



#### 【NOTE】query中引用带空格的列名

对于含有空格的列名，需要使用`` `col name` ``的方式进行引用。

#### 【END】

同时，在`query`中还注册了若干英语的字面用法，帮助提高可读性，例如：`or, and, or, is in, not in`。例如，筛选出男生中不是大一大二的学生：


```python
df.query('(Grade not in ["Freshman", "Sophomore"]) and (Gender == "Male")').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>16</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Xiaoqiang Qin</td>
      <td>Male</td>
      <td>68.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>17</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Peng Wang</td>
      <td>Male</td>
      <td>65.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>18</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Xiaofeng Sun</td>
      <td>Male</td>
      <td>71.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>21</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Xiaopeng Shen</td>
      <td>Male</td>
      <td>62.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



此外，在字符串中出现与列表的比较时，`==`和`!=`分别表示元素出现在列表和没有出现在列表，等价于`is in`和`not in`，例如查询所有大三和大四的学生：


```python
df.query('Grade == ["Junior", "Senior"]').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>7</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Gaoqiang Qian</td>
      <td>Female</td>
      <td>50.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>9</th>
      <td>Peking University</td>
      <td>Junior</td>
      <td>Juan Xu</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
    <tr>
      <th>11</th>
      <td>Tsinghua University</td>
      <td>Junior</td>
      <td>Xiaoquan Lv</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>12</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Senior</td>
      <td>Peng You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



对于`query`中的字符串，如果要引用外部变量，只需在变量名前加`@`符号。例如，取出体重位于70kg到80kg之间的学生：


```python
low, high =70, 80
# df.query('Weight.between(@low, @high)')
df.query('Weight>@low and Weight <@high').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>School</th>
      <th>Grade</th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>Fudan University</td>
      <td>Sophomore</td>
      <td>Gaojuan You</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>10</th>
      <td>Shanghai Jiao Tong University</td>
      <td>Freshman</td>
      <td>Xiaopeng Zhou</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>18</th>
      <td>Tsinghua University</td>
      <td>Senior</td>
      <td>Xiaofeng Sun</td>
      <td>Male</td>
      <td>71.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>35</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Gaoli Zhao</td>
      <td>Male</td>
      <td>78.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>36</th>
      <td>Peking University</td>
      <td>Freshman</td>
      <td>Xiaojuan Qin</td>
      <td>Male</td>
      <td>79.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>



### 6. 随机抽样

如果把`DataFrame`的每一行看作一个样本，或把每一列看作一个特征，再把整个`DataFrame`看作总体，想要对样本或特征进行随机抽样就可以用`sample`函数。有时在拿到大型数据集后，想要对统计特征进行计算来了解数据的大致分布，但是这很费时间。同时，由于许多统计特征在等概率不放回的简单随机抽样条件下，是总体统计特征的无偏估计，比如样本均值和总体均值，那么就可以先从整张表中抽出一部分来做近似估计。

`sample`函数中的主要参数为`n, axis, frac, replace, weights`，前三个分别是指抽样数量、抽样的方向（0为行、1为列）和抽样比例（0.3则为从总体中抽出30%的样本）。

`replace`和`weights`分别是指是否放回和每个样本的抽样相对概率，当`replace = True`则表示有放回抽样。例如，对下面构造的`df_sample`以`value`值的相对大小为抽样概率进行有放回抽样，抽样数量为3。


```python
df_sample = pd.DataFrame({'id': list('abcde'), 'value': [1, 2, 3, 4, 90]})
df_sample
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>c</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>d</td>
      <td>4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>e</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_sample.sample(3, replace = True, weights = df_sample.value)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>e</td>
      <td>90</td>
    </tr>
    <tr>
      <th>4</th>
      <td>e</td>
      <td>90</td>
    </tr>
    <tr>
      <th>4</th>
      <td>e</td>
      <td>90</td>
    </tr>
  </tbody>
</table>
</div>



## 二、多级索引
### 1. 多级索引及其表的结构

为了更加清晰地说明具有多级索引的`DataFrame`结构，下面新构造一张表，读者可以忽略这里的构造方法，它们将会在第4小节被更详细地讲解。


```python
np.random.seed(0)
multi_index = pd.MultiIndex.from_product([list('ABCD'), df.Gender.unique()], names=('School', 'Gender'))
multi_column = pd.MultiIndex.from_product([['Height', 'Weight'], df.Grade.unique()], names=('Indicator', 'Grade'))
df_multi = pd.DataFrame(np.c_[(np.random.randn(8,4)*5 + 163).tolist(), (np.random.randn(8,4)*5 + 65).tolist()],
                        index = multi_index, columns = multi_column).round(1)
df_multi
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Indicator</th>
      <th colspan="4" halign="left">Height</th>
      <th colspan="4" halign="left">Weight</th>
    </tr>
    <tr>
      <th></th>
      <th>Grade</th>
      <th>Freshman</th>
      <th>Senior</th>
      <th>Sophomore</th>
      <th>Junior</th>
      <th>Freshman</th>
      <th>Senior</th>
      <th>Sophomore</th>
      <th>Junior</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Gender</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>Female</th>
      <td>171.8</td>
      <td>165.0</td>
      <td>167.9</td>
      <td>174.2</td>
      <td>60.6</td>
      <td>55.1</td>
      <td>63.3</td>
      <td>65.8</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>172.3</td>
      <td>158.1</td>
      <td>167.8</td>
      <td>162.2</td>
      <td>71.2</td>
      <td>71.0</td>
      <td>63.1</td>
      <td>63.5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">B</th>
      <th>Female</th>
      <td>162.5</td>
      <td>165.1</td>
      <td>163.7</td>
      <td>170.3</td>
      <td>59.8</td>
      <td>57.9</td>
      <td>56.5</td>
      <td>74.8</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>166.8</td>
      <td>163.6</td>
      <td>165.2</td>
      <td>164.7</td>
      <td>62.5</td>
      <td>62.8</td>
      <td>58.7</td>
      <td>68.9</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">C</th>
      <th>Female</th>
      <td>170.5</td>
      <td>162.0</td>
      <td>164.6</td>
      <td>158.7</td>
      <td>56.9</td>
      <td>63.9</td>
      <td>60.5</td>
      <td>66.9</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>150.2</td>
      <td>166.3</td>
      <td>167.3</td>
      <td>159.3</td>
      <td>62.4</td>
      <td>59.1</td>
      <td>64.9</td>
      <td>67.1</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">D</th>
      <th>Female</th>
      <td>174.3</td>
      <td>155.7</td>
      <td>163.2</td>
      <td>162.1</td>
      <td>65.3</td>
      <td>66.5</td>
      <td>61.8</td>
      <td>63.2</td>
    </tr>
    <tr>
      <th>Male</th>
      <td>170.7</td>
      <td>170.3</td>
      <td>163.8</td>
      <td>164.9</td>
      <td>61.6</td>
      <td>63.2</td>
      <td>60.9</td>
      <td>56.4</td>
    </tr>
  </tbody>
</table>
</div>



下图通过颜色区分，标记了`DataFrame`的结构。与单层索引的表一样，具备元素值、行索引和列索引三个部分。其中，这里的行索引和列索引都是`MultiIndex`类型，只不过**索引中的一个元素是元组**而不是单层索引中的标量。例如，行索引的第四个元素为`("B", "Male")`，列索引的第二个元素为`("Height", "Senior")`，这里需要注意，外层连续出现相同的值时，第一次之后出现的会被隐藏显示，使结果的可读性增强。

<img src="../source/_static/multi_index.png" width="50%">

与单层索引类似，`MultiIndex`也具有名字属性，图中的`School`和`Gender`分别对应了表的第一层和第二层行索引的名字，`Indicator`和`Grade`分别对应了第一层和第二层列索引的名字。

索引的名字和值属性分别可以通过`names`和`values`获得：


```python
df_multi.index.names
```




    FrozenList(['School', 'Gender'])




```python
df_multi.columns.names
```




    FrozenList(['Indicator', 'Grade'])




```python
df_multi.index.values
```




    array([('A', 'Female'), ('A', 'Male'), ('B', 'Female'), ('B', 'Male'),
           ('C', 'Female'), ('C', 'Male'), ('D', 'Female'), ('D', 'Male')],
          dtype=object)




```python
df_multi.columns.values
```




    array([('Height', 'Freshman'), ('Height', 'Senior'),
           ('Height', 'Sophomore'), ('Height', 'Junior'),
           ('Weight', 'Freshman'), ('Weight', 'Senior'),
           ('Weight', 'Sophomore'), ('Weight', 'Junior')], dtype=object)



如果想要得到某一层的索引，则需要通过`get_level_values`获得：


```python
df_multi.index.get_level_values(0)
```




    Index(['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D'], dtype='object', name='School')



但对于索引而言，无论是单层还是多层，用户都无法通过`index_obj[0] = item`的方式来修改元素，也不能通过`index_name[0] = new_name`的方式来修改名字，关于如何修改这些属性的话题将在第三节被讨论。

### 2. 多级索引中的loc索引器

熟悉了结构后，现在回到原表，将学校和年级设为索引，此时的行为多级索引，列为单级索引，由于默认状态的列索引不含名字，因此对应于刚刚图中`Indicator`和`Grade`的索引名位置是空缺的。


```python
df_multi = df.set_index(['School', 'Grade'])
df_multi.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Freshman</th>
      <td>Gaopeng Yang</td>
      <td>Female</td>
      <td>46.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <th>Freshman</th>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Shanghai Jiao Tong University</th>
      <th>Senior</th>
      <td>Mei Sun</td>
      <td>Male</td>
      <td>89.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">Fudan University</th>
      <th>Sophomore</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Gaojuan You</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



由于多级索引中的单个元素以元组为单位，因此之前在第一节介绍的`loc`和`iloc`方法完全可以照搬，只需把标量的位置替换成对应的元组，不过在索引前最好对`MultiIndex`进行排序以避免性能警告：


```python
df_multi = df_multi.sort_index()
# df_multi
df_multi.loc[('Fudan University', 'Junior')].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Junior</th>
      <td>Yanli You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Chunqiang Chu</td>
      <td>Male</td>
      <td>72.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changfeng Lv</td>
      <td>Male</td>
      <td>76.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Yanjuan Lv</td>
      <td>Female</td>
      <td>49.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoqiang Zhou</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_multi.loc[[('Fudan University', 'Senior'), ('Shanghai Jiao Tong University', 'Freshman')]].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Senior</th>
      <td>Chengpeng Zheng</td>
      <td>Female</td>
      <td>38.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Feng Zhou</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Gaomei Lv</td>
      <td>Female</td>
      <td>34.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chunli Lv</td>
      <td>Female</td>
      <td>56.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_multi.loc[df_multi.Weight > 70].head() # 布尔列表也是可用的
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Freshman</th>
      <td>Feng Wang</td>
      <td>Male</td>
      <td>74.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Chunqiang Chu</td>
      <td>Male</td>
      <td>72.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changfeng Lv</td>
      <td>Male</td>
      <td>76.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Zhou</td>
      <td>Male</td>
      <td>81.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Qian</td>
      <td>Male</td>
      <td>73.0</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_multi.loc[lambda x:('Fudan University','Junior')].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Fudan University</th>
      <th>Junior</th>
      <td>Yanli You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Chunqiang Chu</td>
      <td>Male</td>
      <td>72.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changfeng Lv</td>
      <td>Male</td>
      <td>76.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Yanjuan Lv</td>
      <td>Female</td>
      <td>49.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoqiang Zhou</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



#### 【练一练】

与单层索引类似，若存在重复元素，则不能使用切片，请去除重复索引后给出一个元素切片的例子。

#### 【END】


```python
df_dup = df_multi[~df_multi.index.duplicated()]
df_dup.loc[('Fudan University',  'Freshman'):('Peking University',  'Freshman')]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">Fudan University</th>
      <th>Freshman</th>
      <td>Changqiang Yang</td>
      <td>Female</td>
      <td>49.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Yanli You</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Senior</th>
      <td>Chengpeng Zheng</td>
      <td>Female</td>
      <td>38.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Xiaojuan Sun</td>
      <td>Female</td>
      <td>41.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Peking University</th>
      <th>Freshman</th>
      <td>Changqiang You</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>



此外，在多级索引中的元组有一种特殊的用法，可以对多层的元素进行交叉组合后索引，但同时需要指定`loc`的列，全选则用`:`表示。其中，每一层需要选中的元素用列表存放，传入`loc`的形式为`[(level_0_list, level_1_list), cols]`。例如，想要得到所有北大和复旦的大二大三学生，可以如下写出：


```python
res = df_multi.loc[(['Peking University', 'Fudan University'], ['Sophomore', 'Junior']), :]
res.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Peking University</th>
      <th>Sophomore</th>
      <td>Changmei Xu</td>
      <td>Female</td>
      <td>43.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Xiaopeng Qin</td>
      <td>Male</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Mei Xu</td>
      <td>Female</td>
      <td>39.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Xiaoli Zhou</td>
      <td>Female</td>
      <td>55.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Sophomore</th>
      <td>Peng Han</td>
      <td>Female</td>
      <td>34.0</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




```python
res.shape
```




    (33, 4)



下面的语句和上面类似，但仍然传入的是元素（这里为元组）的列表，它们的意义是不同的，表示的是选出北大的大三学生和复旦的大二学生：


```python
res = df_multi.loc[[('Peking University', 'Junior'), ('Fudan University', 'Sophomore')]]
res.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Name</th>
      <th>Gender</th>
      <th>Weight</th>
      <th>Transfer</th>
    </tr>
    <tr>
      <th>School</th>
      <th>Grade</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">Peking University</th>
      <th>Junior</th>
      <td>Juan Xu</td>
      <td>Female</td>
      <td>NaN</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Changjuan You</td>
      <td>Female</td>
      <td>47.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoli Xu</td>
      <td>Female</td>
      <td>48.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Gaoquan Zhou</td>
      <td>Male</td>
      <td>70.0</td>
      <td>N</td>
    </tr>
    <tr>
      <th>Junior</th>
      <td>Qiang You</td>
      <td>Female</td>
      <td>56.0</td>
      <td>N</td>
    </tr>
  </tbody>
</table>
</div>




```python
res.shape
```




    (16, 4)



### 3. IndexSlice对象

前面介绍的方法，即使在索引不重复的时候，也只能对元组整体进行切片，而不能对每层进行切片，也不允许将切片和布尔列表混合使用，引入`IndexSlice`对象就能解决这个问题。`Slice`对象一共有两种形式，第一种为`loc[idx[*,*]]`型，第二种为`loc[idx[*,*],idx[*,*]]`型，下面将进行介绍。为了方便演示，下面构造一个**索引不重复的**`DataFrame`：


```python
np.random.seed(0)
L1,L2 = ['A','B','C'],['a','b','c']
mul_index1 = pd.MultiIndex.from_product([L1,L2],names=('Upper', 'Lower'))
L3,L4 = ['D','E','F'],['d','e','f']
mul_index2 = pd.MultiIndex.from_product([L3,L4],names=('Big', 'Small'))
df_ex = pd.DataFrame(np.random.randint(-9,10,(9,9)), index=mul_index1, columns=mul_index2)
df_ex
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th colspan="3" halign="left">D</th>
      <th colspan="3" halign="left">E</th>
      <th colspan="3" halign="left">F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">A</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
      <td>-4</td>
      <td>4</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">B</th>
      <th>a</th>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
    </tr>
    <tr>
      <th>b</th>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
    </tr>
    <tr>
      <th>c</th>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
    </tr>
    <tr>
      <th rowspan="3" valign="top">C</th>
      <th>a</th>
      <td>-6</td>
      <td>-3</td>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
    </tr>
    <tr>
      <th>b</th>
      <td>1</td>
      <td>2</td>
      <td>-5</td>
      <td>-3</td>
      <td>-5</td>
      <td>6</td>
      <td>-6</td>
      <td>3</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-1</td>
      <td>5</td>
      <td>6</td>
      <td>-6</td>
      <td>6</td>
      <td>4</td>
      <td>7</td>
      <td>8</td>
      <td>-4</td>
    </tr>
  </tbody>
</table>
</div>



为了使用`silce`对象，先要进行定义：


```python
idx = pd.IndexSlice
```

【a】`loc[idx[*,*]]`型

这种情况并不能进行多层分别切片，前一个`*`表示行的选择，后一个`*`表示列的选择，与单纯的`loc`是类似的：


```python
df_ex.loc[idx['C':, ('D', 'f'):]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th>D</th>
      <th colspan="3" halign="left">E</th>
      <th colspan="3" halign="left">F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">C</th>
      <th>a</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-5</td>
      <td>-3</td>
      <td>-5</td>
      <td>6</td>
      <td>-6</td>
      <td>3</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>c</th>
      <td>6</td>
      <td>-6</td>
      <td>6</td>
      <td>4</td>
      <td>7</td>
      <td>8</td>
      <td>-4</td>
    </tr>
  </tbody>
</table>
</div>



另外，也支持布尔序列的索引：


```python
df_ex.loc[idx[:'A', lambda x:x.sum()>0]] # 列和大于0
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th colspan="2" halign="left">D</th>
      <th>F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>d</th>
      <th>e</th>
      <th>e</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="3" valign="top">A</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>9</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-3</td>
      <td>3</td>
      <td>-4</td>
    </tr>
    <tr>
      <th>c</th>
      <td>-1</td>
      <td>0</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



【b】`loc[idx[*,*],idx[*,*]]`型

这种情况能够分层进行切片，前一个`idx`指代的是行索引，后一个是列索引。


```python
df_ex.loc[idx[:'A', 'b':], idx['E':, 'e':]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>Big</th>
      <th colspan="2" halign="left">E</th>
      <th colspan="2" halign="left">F</th>
    </tr>
    <tr>
      <th></th>
      <th>Small</th>
      <th>e</th>
      <th>f</th>
      <th>e</th>
      <th>f</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">A</th>
      <th>b</th>
      <td>-2</td>
      <td>5</td>
      <td>-4</td>
      <td>4</td>
    </tr>
    <tr>
      <th>c</th>
      <td>6</td>
      <td>6</td>
      <td>9</td>
      <td>-6</td>
    </tr>
  </tbody>
</table>
</div>



### 4. 多级索引的构造

前面提到了多级索引表的结构和切片，那么除了使用`set_index`之外，如何自己构造多级索引呢？常用的有`from_tuples, from_arrays, from_product`三种方法，它们都是`pd.MultiIndex`对象下的函数。

`from_tuples`指根据传入由元组组成的列表进行构造：


```python
my_tuple = [('a','cat'),('a','dog'),('b','cat'),('b','dog')]
pd.MultiIndex.from_tuples(my_tuple, names=['First','Second'])
```




    MultiIndex([('a', 'cat'),
                ('a', 'dog'),
                ('b', 'cat'),
                ('b', 'dog')],
               names=['First', 'Second'])



`from_arrays`指根据传入列表中，对应层的列表进行构造：


```python
my_array = [list('aabb'), ['cat', 'dog']*2]
pd.MultiIndex.from_arrays(my_array, names=['First','Second'])
```




    MultiIndex([('a', 'cat'),
                ('a', 'dog'),
                ('b', 'cat'),
                ('b', 'dog')],
               names=['First', 'Second'])



`from_product`指根据给定多个列表的笛卡尔积进行构造：


```python
my_list1 = ['a','b']
my_list2 = ['cat','dog']
pd.MultiIndex.from_product([my_list1, my_list2], names=['First','Second'])
```




    MultiIndex([('a', 'cat'),
                ('a', 'dog'),
                ('b', 'cat'),
                ('b', 'dog')],
               names=['First', 'Second'])



## 三、索引的常用方法
### 1. 索引层的交换和删除
为了方便理解交换的过程，这里构造一个三级索引的例子：


```python
np.random.seed(0)
L1,L2,L3 = ['A','B'],['a','b'],['alpha','beta']
mul_index1 = pd.MultiIndex.from_product([L1,L2,L3], names=('Upper', 'Lower','Extra'))
L4,L5,L6 = ['C','D'],['c','d'],['cat','dog']
mul_index2 = pd.MultiIndex.from_product([L4,L5,L6], names=('Big', 'Small', 'Other'))
df_ex = pd.DataFrame(np.random.randint(-9,10,(8,8)), index=mul_index1,  columns=mul_index2)
df_ex
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">B</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
      <td>-6</td>
      <td>-3</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



索引层的交换由`swaplevel`和`reorder_levels`完成，前者只能交换两个层，而后者可以交换任意层，两者都可以指定交换的是轴是哪一个，即行索引或列索引：


```python
df_ex.swaplevel(0,2,axis=1).head() # 列索引的第一层和第三层交换
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th>c</th>
      <th>c</th>
      <th>d</th>
      <th>d</th>
      <th>c</th>
      <th>c</th>
      <th>d</th>
      <th>d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th>C</th>
      <th>C</th>
      <th>C</th>
      <th>C</th>
      <th>D</th>
      <th>D</th>
      <th>D</th>
      <th>D</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_ex.reorder_levels([2,0,1],axis=0).head() # 列表数字指代原来索引中的层
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Extra</th>
      <th>Upper</th>
      <th>Lower</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>alpha</th>
      <th>A</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <th>A</th>
      <th>a</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>alpha</th>
      <th>A</th>
      <th>b</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <th>A</th>
      <th>b</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>alpha</th>
      <th>B</th>
      <th>a</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



#### 【NOTE】轴之间的索引交换
这里只涉及行或列索引内部的交换，不同方向索引之间的交换将在第五章中被讨论。
#### 【END】
若想要删除某一层的索引，可以使用`droplevel`方法：


```python
df_ex.droplevel(1,axis=1)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">B</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
      <td>-6</td>
      <td>-3</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_ex.droplevel([0,1],axis=0)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
    </tr>
    <tr>
      <th>alpha</th>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
      <td>-6</td>
      <td>-3</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



### 2. 索引属性的修改
通过`rename_axis`可以对索引层的名字进行修改，常用的修改方式是传入字典的映射：


```python
df_ex.rename_axis(index={'Upper':'Changed_row'}, columns={'Other':'Changed_Col'}).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Changed_Col</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Changed_row</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



通过`rename`可以对索引的值进行修改，如果是多级索引需要指定修改的层号`level`：


```python
df_ex.rename(columns={'cat':'not_cat'}, level=2).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>not_cat</th>
      <th>dog</th>
      <th>not_cat</th>
      <th>dog</th>
      <th>not_cat</th>
      <th>dog</th>
      <th>not_cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



传入参数也可以是函数，其输入值就是索引元素：


```python
df_ex.rename(index=lambda x:str.upper(x), level=2).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>ALPHA</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>BETA</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>ALPHA</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>BETA</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>ALPHA</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



#### 【练一练】
尝试在`rename_axis`中使用函数完成与例子(rename_axis修改索引名的例子)中一样的功能。
#### 【END】


```python
def foo(x):
    if x == 'Upper':
        return 'Changed_row'
    elif x == 'Other':
        return 'Changed_col'
df_ex.rename_axis(index = foo, columns = foo).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th></th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th></th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Changed_col</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Changed_row</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



对于整个索引的元素替换，可以利用迭代器实现：


```python
new_values = iter(list('abcdefgh'))
df_ex.rename(index=lambda x:next(new_values), level=2)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>a</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>b</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>c</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>d</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th rowspan="4" valign="top">B</th>
      <th rowspan="2" valign="top">a</th>
      <th>e</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
    <tr>
      <th>f</th>
      <td>-9</td>
      <td>-5</td>
      <td>-4</td>
      <td>-3</td>
      <td>-1</td>
      <td>8</td>
      <td>6</td>
      <td>-5</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>g</th>
      <td>0</td>
      <td>1</td>
      <td>-8</td>
      <td>-8</td>
      <td>-2</td>
      <td>0</td>
      <td>-6</td>
      <td>-3</td>
    </tr>
    <tr>
      <th>h</th>
      <td>2</td>
      <td>5</td>
      <td>9</td>
      <td>-9</td>
      <td>5</td>
      <td>-6</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



若想要对某个位置的元素进行修改，在单层索引时容易实现，即先取出索引的`values`属性，再给对得到的列表进行修改，最后再对`index`对象重新赋值。但是如果是多级索引的话就有些麻烦，一个解决的方案是先把某一层索引临时转为表的元素，然后再进行修改，最后重新设定为索引，下面一节将介绍这些操作。

另外一个需要介绍的函数是`map`，它是定义在`Index`上的方法，与前面`rename`方法中层的函数式用法是类似的，只不过它传入的不是层的标量值，而是直接传入索引的元组，这为用户进行跨层的修改提供了遍历。例如，可以等价地写出上面的字符串转大写的操作：


```python
df_temp = df_ex.copy()
new_idx = df_temp.index.map(lambda x: (x[0], x[1], str.upper(x[2])))
df_temp.index = new_idx
df_temp.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
    <tr>
      <th>Upper</th>
      <th>Lower</th>
      <th>Extra</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>ALPHA</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>BETA</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>ALPHA</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>BETA</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>ALPHA</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



关于`map`的另一个使用方法是对多级索引的压缩，这在第四章和第五章的一些操作中是有用的：


```python
df_temp = df_ex.copy()
new_idx = df_temp.index.map(lambda x: (x[0]+'-'+x[1]+'-'+x[2]))
df_temp.index = new_idx
df_temp.head() # 单层索引
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A-a-alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>A-a-beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th>A-b-alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>A-b-beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B-a-alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



同时，也可以反向地展开：


```python
new_idx = df_temp.index.map(lambda x:tuple(x.split('-')))
df_temp.index = new_idx
df_temp.head() # 三层索引
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th></th>
      <th>Big</th>
      <th colspan="4" halign="left">C</th>
      <th colspan="4" halign="left">D</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Small</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
      <th colspan="2" halign="left">c</th>
      <th colspan="2" halign="left">d</th>
    </tr>
    <tr>
      <th></th>
      <th></th>
      <th>Other</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
      <th>cat</th>
      <th>dog</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="4" valign="top">A</th>
      <th rowspan="2" valign="top">a</th>
      <th>alpha</th>
      <td>3</td>
      <td>6</td>
      <td>-9</td>
      <td>-6</td>
      <td>-6</td>
      <td>-2</td>
      <td>0</td>
      <td>9</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-5</td>
      <td>-3</td>
      <td>3</td>
      <td>-8</td>
      <td>-3</td>
      <td>-2</td>
      <td>5</td>
      <td>8</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">b</th>
      <th>alpha</th>
      <td>-4</td>
      <td>4</td>
      <td>-1</td>
      <td>0</td>
      <td>7</td>
      <td>-4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <th>beta</th>
      <td>-9</td>
      <td>9</td>
      <td>-6</td>
      <td>8</td>
      <td>5</td>
      <td>-2</td>
      <td>-9</td>
      <td>-8</td>
    </tr>
    <tr>
      <th>B</th>
      <th>a</th>
      <th>alpha</th>
      <td>0</td>
      <td>-9</td>
      <td>1</td>
      <td>-6</td>
      <td>2</td>
      <td>9</td>
      <td>-7</td>
      <td>-9</td>
    </tr>
  </tbody>
</table>
</div>



### 3. 索引的设置与重置
为了说明本节的函数，下面构造一个新表：


```python
df_new = pd.DataFrame({'A':list('aacd'), 'B':list('PQRT'), 'C':[1,2,3,4]})
df_new
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>a</td>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>c</td>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>d</td>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



索引的设置可以使用`set_index`完成，这里的主要参数是`append`，表示是否来保留原来的索引，直接把新设定的添加到原索引的内层：


```python
df_new.set_index('A')
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>a</th>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_new.set_index('A', append=True)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th></th>
      <th>A</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <th>a</th>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <th>a</th>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <th>c</th>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <th>d</th>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



可以同时指定多个列作为索引：


```python
df_new.set_index(['A', 'B'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th>B</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>P</th>
      <td>1</td>
    </tr>
    <tr>
      <th>Q</th>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <th>R</th>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <th>T</th>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



如果想要添加索引的列没有出现再其中，那么可以直接在参数中传入相应的`Series`：


```python
my_index = pd.Series(list('WXYZ'), name='D')
df_new = df_new.set_index(['A', my_index])
df_new
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th>D</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">a</th>
      <th>W</th>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>X</th>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <th>Y</th>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <th>Z</th>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



`reset_index`是`set_index`的逆函数，其主要参数是`drop`，表示是否要把去掉的索引层丢弃，而不是添加到列中：


```python
df_new.reset_index(['D'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>D</th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>W</td>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>a</th>
      <td>X</td>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <td>Y</td>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <td>Z</td>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_new.reset_index(['D'], drop=True)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>B</th>
      <th>C</th>
    </tr>
    <tr>
      <th>A</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>a</th>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>c</th>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>d</th>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



如果重置了所有的索引，那么`pandas`会直接重新生成一个默认索引：


```python
df_new.reset_index()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>D</th>
      <th>B</th>
      <th>C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>W</td>
      <td>P</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>a</td>
      <td>X</td>
      <td>Q</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>c</td>
      <td>Y</td>
      <td>R</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>d</td>
      <td>Z</td>
      <td>T</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



### 4. 索引的变形
在某些场合下，需要对索引做一些扩充或者剔除，更具体地要求是给定一个新的索引，把原表中相应的索引对应元素填充到新索引构成的表中。例如，下面的表中给出了员工信息，需要重新制作一张新的表，要求增加一名员工的同时去掉身高列并增加性别列：


```python
df_reindex = pd.DataFrame({"Weight":[60,70,80], "Height":[176,180,179]}, index=['1001','1003','1002'])
df_reindex
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Weight</th>
      <th>Height</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1001</th>
      <td>60</td>
      <td>176</td>
    </tr>
    <tr>
      <th>1003</th>
      <td>70</td>
      <td>180</td>
    </tr>
    <tr>
      <th>1002</th>
      <td>80</td>
      <td>179</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_reindex.reindex(index=['1001','1002','1003','1004'], columns=['Weight','Gender'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Weight</th>
      <th>Gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1001</th>
      <td>60.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1002</th>
      <td>80.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1003</th>
      <td>70.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1004</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



这种需求常出现在时间序列索引的时间点填充以及`ID`编号的扩充。另外，需要注意的是原来表中的数据和新表中会根据索引自动对齐，例如原先的1002号位置在1003号之后，而新表中相反，那么`reindex`中会根据元素对齐，与位置无关。

还有一个与`reindex`功能类似的函数是`reindex_like`，其功能是仿照传入的表的索引来进行被调用表索引的变形。例如，现在以及存在一张表具备了目标索引的条件，那么上述功能可以如下等价地写出：


```python
df_existed = pd.DataFrame(index=['1001','1002','1003','1004'], columns=['Weight','Gender'])
df_reindex.reindex_like(df_existed)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Weight</th>
      <th>Gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1001</th>
      <td>60.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1002</th>
      <td>80.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1003</th>
      <td>70.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1004</th>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



## 四、索引运算
### 1. 集合的运算法则

经常会有一种利用集合运算来取出符合条件行的需求，例如有两张表`A`和`B`，它们的索引都是员工编号，现在需要筛选出两表索引交集的所有员工信息，此时通过`Index`上的运算操作就很容易实现。

不过在此之前，不妨先复习一下常见的四种集合运算：

$$\rm S_A.intersection(S_B) = \rm S_A \cap S_B \Leftrightarrow \rm \{x|x\in S_A\, and\, x\in S_B\}$$
$$\rm S_A.union(S_B) = \rm S_A \cup S_B \Leftrightarrow \rm \{x|x\in S_A\, or\, x\in S_B\}$$
$$\rm S_A.difference(S_B) = \rm S_A - S_B \Leftrightarrow \rm \{x|x\in S_A\, and\, x\notin S_B\}$$
$$\rm S_A.symmetric\_difference(S_B) = \rm S_A\triangle S_B\Leftrightarrow \rm \{x|x\in S_A\cup S_B - S_A\cap S_B\}$$

### 2. 一般的索引运算

由于集合的元素是互异的，但是索引中可能有相同的元素，先用`unique`去重后再进行运算。下面构造两张最为简单的示例表进行演示：


```python
df_set_1 = pd.DataFrame([[0,1],[1,2],[3,4]], index = pd.Index(['a','b','a'],name='id1'))
df_set_2 = pd.DataFrame([[4,5],[2,6],[7,1]], index = pd.Index(['b','b','c'], name = 'id2'))
id1, id2 = df_set_1.index.unique(), df_set_2.index.unique()
id1.intersection(id2)
```




    Index(['b'], dtype='object')




```python
id1.union(id2)
```




    Index(['a', 'b', 'c'], dtype='object')




```python
id1.difference(id2)
```




    Index(['a'], dtype='object')




```python
id1.symmetric_difference(id2)
```




    Index(['a', 'c'], dtype='object')



上述的四类运算还可以用等价的符号表示代替如下：


```python
id1 & id2
```




    Index(['b'], dtype='object')




```python
id1 | id2
```




    Index(['a', 'b', 'c'], dtype='object')




```python
(id1 ^ id2) & id1
```




    Index(['a'], dtype='object')




```python
id1 ^ id2 # ^符号即对称差
```




    Index(['a', 'c'], dtype='object')



若两张表需要做集合运算的列并没有被设置索引，一种办法是先转成索引，运算后再恢复，另一种方法是利用`isin`函数，例如在重置索引的第一张表中选出id列交集的所在行：


```python
df_set_in_col_1 = df_set_1.reset_index()
df_set_in_col_2 = df_set_2.reset_index()
df_set_in_col_1
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id1</th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>a</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>a</td>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_set_in_col_2
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id2</th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>b</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>2</td>
      <td>6</td>
    </tr>
    <tr>
      <th>2</th>
      <td>c</td>
      <td>7</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>




```python
df_set_in_col_1[df_set_in_col_1.id1.isin(df_set_in_col_2.id2)]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id1</th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>b</td>
      <td>1</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



## 五、练习
### Ex1：公司员工数据集
现有一份公司员工数据集：


```python
df = pd.read_csv('../data/company.csv')
df.head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
      <th>department</th>
      <th>job_title</th>
      <th>gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1318</td>
      <td>1/3/1954</td>
      <td>61</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>CEO</td>
      <td>M</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1319</td>
      <td>1/3/1957</td>
      <td>58</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>VP Stores</td>
      <td>F</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1320</td>
      <td>1/2/1955</td>
      <td>60</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>Legal Counsel</td>
      <td>F</td>
    </tr>
  </tbody>
</table>
</div>



1. 分别只使用`query`和`loc`选出年龄不超过四十岁且工作部门为`Dairy`或`Bakery`的男性。
2. 选出员工`ID`号 为奇数所在行的第1、第3和倒数第2列。
3. 按照以下步骤进行索引操作：

* 把后三列设为索引后交换内外两层
* 恢复中间一层
* 修改外层索引名为`Gender`
* 用下划线合并两层行索引
* 把行索引拆分为原状态
* 修改索引名为原表名称
* 恢复默认索引并将列保持为原表的相对位置


```python
#1
df.loc[(df.age<=40) & df.department.isin(['Dairy', 'Bakery']) & (df.gender == 'M')].head()

df.query('(age<=40) and (department in ["Dairy", "Bakery"]) and (gender =="M") ').head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
      <th>department</th>
      <th>job_title</th>
      <th>gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3611</th>
      <td>5791</td>
      <td>1/14/1975</td>
      <td>40</td>
      <td>Kelowna</td>
      <td>Dairy</td>
      <td>Dairy Person</td>
      <td>M</td>
    </tr>
    <tr>
      <th>3613</th>
      <td>5793</td>
      <td>1/22/1975</td>
      <td>40</td>
      <td>Richmond</td>
      <td>Bakery</td>
      <td>Baker</td>
      <td>M</td>
    </tr>
    <tr>
      <th>3615</th>
      <td>5795</td>
      <td>1/30/1975</td>
      <td>40</td>
      <td>Nanaimo</td>
      <td>Dairy</td>
      <td>Dairy Person</td>
      <td>M</td>
    </tr>
    <tr>
      <th>3617</th>
      <td>5797</td>
      <td>2/3/1975</td>
      <td>40</td>
      <td>Nanaimo</td>
      <td>Dairy</td>
      <td>Dairy Person</td>
      <td>M</td>
    </tr>
    <tr>
      <th>3618</th>
      <td>5798</td>
      <td>2/4/1975</td>
      <td>40</td>
      <td>Surrey</td>
      <td>Dairy</td>
      <td>Dairy Person</td>
      <td>M</td>
    </tr>
  </tbody>
</table>
</div>




```python
#2
df.iloc[(df.EmployeeID%2 == 1).values, [0, 2, -1]]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>EmployeeID</th>
      <th>age</th>
      <th>gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>1319</td>
      <td>58</td>
      <td>F</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1321</td>
      <td>56</td>
      <td>M</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1323</td>
      <td>53</td>
      <td>M</td>
    </tr>
    <tr>
      <th>6</th>
      <td>1325</td>
      <td>51</td>
      <td>F</td>
    </tr>
    <tr>
      <th>8</th>
      <td>1329</td>
      <td>48</td>
      <td>F</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>6276</th>
      <td>7659</td>
      <td>26</td>
      <td>F</td>
    </tr>
    <tr>
      <th>6277</th>
      <td>7741</td>
      <td>25</td>
      <td>M</td>
    </tr>
    <tr>
      <th>6278</th>
      <td>7801</td>
      <td>25</td>
      <td>F</td>
    </tr>
    <tr>
      <th>6280</th>
      <td>8181</td>
      <td>22</td>
      <td>M</td>
    </tr>
    <tr>
      <th>6281</th>
      <td>8223</td>
      <td>21</td>
      <td>M</td>
    </tr>
  </tbody>
</table>
<p>3126 rows × 3 columns</p>
</div>




```python
# 3.1 把后三列设为索引后交换内外两层
# df.columns[-3:].values
df_tmp = df.set_index(list(df.columns[-3:].values))
df_tmp = df_tmp.reorder_levels([2, 1, 0], axis = 0)
df_tmp.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th></th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
    </tr>
    <tr>
      <th>gender</th>
      <th>job_title</th>
      <th>department</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>M</th>
      <th>CEO</th>
      <th>Executive</th>
      <td>1318</td>
      <td>1/3/1954</td>
      <td>61</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">F</th>
      <th>VP Stores</th>
      <th>Executive</th>
      <td>1319</td>
      <td>1/3/1957</td>
      <td>58</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>Legal Counsel</th>
      <th>Executive</th>
      <td>1320</td>
      <td>1/2/1955</td>
      <td>60</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">M</th>
      <th>VP Human Resources</th>
      <th>Executive</th>
      <td>1321</td>
      <td>1/2/1959</td>
      <td>56</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>VP Finance</th>
      <th>Executive</th>
      <td>1322</td>
      <td>1/9/1958</td>
      <td>57</td>
      <td>Vancouver</td>
    </tr>
  </tbody>
</table>
</div>




```python
#3.2 恢复中间一层
df_tmp = df_tmp.reset_index(['job_title'])
df_tmp.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>job_title</th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
    </tr>
    <tr>
      <th>gender</th>
      <th>department</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>M</th>
      <th>Executive</th>
      <td>CEO</td>
      <td>1318</td>
      <td>1/3/1954</td>
      <td>61</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">F</th>
      <th>Executive</th>
      <td>VP Stores</td>
      <td>1319</td>
      <td>1/3/1957</td>
      <td>58</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>Executive</th>
      <td>Legal Counsel</td>
      <td>1320</td>
      <td>1/2/1955</td>
      <td>60</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">M</th>
      <th>Executive</th>
      <td>VP Human Resources</td>
      <td>1321</td>
      <td>1/2/1959</td>
      <td>56</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>Executive</th>
      <td>VP Finance</td>
      <td>1322</td>
      <td>1/9/1958</td>
      <td>57</td>
      <td>Vancouver</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 3.3 修改外层索引名为 Gender
df_tmp.rename_axis(index = {'gender':'Genger'}, inplace = True)
df_tmp.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>job_title</th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
    </tr>
    <tr>
      <th>Genger</th>
      <th>department</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>M</th>
      <th>Executive</th>
      <td>CEO</td>
      <td>1318</td>
      <td>1/3/1954</td>
      <td>61</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">F</th>
      <th>Executive</th>
      <td>VP Stores</td>
      <td>1319</td>
      <td>1/3/1957</td>
      <td>58</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>Executive</th>
      <td>Legal Counsel</td>
      <td>1320</td>
      <td>1/2/1955</td>
      <td>60</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">M</th>
      <th>Executive</th>
      <td>VP Human Resources</td>
      <td>1321</td>
      <td>1/2/1959</td>
      <td>56</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>Executive</th>
      <td>VP Finance</td>
      <td>1322</td>
      <td>1/9/1958</td>
      <td>57</td>
      <td>Vancouver</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 3.4 用下划线合并两层行索引
new_idx = df_tmp.index.map(lambda x:(x[0]+'_'+x[1]))
df_tmp.index = new_idx
df_tmp.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>job_title</th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>M_Executive</th>
      <td>CEO</td>
      <td>1318</td>
      <td>1/3/1954</td>
      <td>61</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>F_Executive</th>
      <td>VP Stores</td>
      <td>1319</td>
      <td>1/3/1957</td>
      <td>58</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>F_Executive</th>
      <td>Legal Counsel</td>
      <td>1320</td>
      <td>1/2/1955</td>
      <td>60</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>M_Executive</th>
      <td>VP Human Resources</td>
      <td>1321</td>
      <td>1/2/1959</td>
      <td>56</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>M_Executive</th>
      <td>VP Finance</td>
      <td>1322</td>
      <td>1/9/1958</td>
      <td>57</td>
      <td>Vancouver</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 3.5 把行索引拆分为原状态
new_idx = df_tmp.index.map(lambda x: tuple(x.split('_')))
df_tmp.index = new_idx
df_tmp.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>job_title</th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>M</th>
      <th>Executive</th>
      <td>CEO</td>
      <td>1318</td>
      <td>1/3/1954</td>
      <td>61</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">F</th>
      <th>Executive</th>
      <td>VP Stores</td>
      <td>1319</td>
      <td>1/3/1957</td>
      <td>58</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>Executive</th>
      <td>Legal Counsel</td>
      <td>1320</td>
      <td>1/2/1955</td>
      <td>60</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">M</th>
      <th>Executive</th>
      <td>VP Human Resources</td>
      <td>1321</td>
      <td>1/2/1959</td>
      <td>56</td>
      <td>Vancouver</td>
    </tr>
    <tr>
      <th>Executive</th>
      <td>VP Finance</td>
      <td>1322</td>
      <td>1/9/1958</td>
      <td>57</td>
      <td>Vancouver</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 3.6 修改索引名为原表名称
df_tmp = df_tmp.rename_axis(index = ['gender', 'department'])
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
      <th>department</th>
      <th>job_title</th>
      <th>gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1318</td>
      <td>1/3/1954</td>
      <td>61</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>CEO</td>
      <td>M</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1319</td>
      <td>1/3/1957</td>
      <td>58</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>VP Stores</td>
      <td>F</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1320</td>
      <td>1/2/1955</td>
      <td>60</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>Legal Counsel</td>
      <td>F</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1321</td>
      <td>1/2/1959</td>
      <td>56</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>VP Human Resources</td>
      <td>M</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1322</td>
      <td>1/9/1958</td>
      <td>57</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>VP Finance</td>
      <td>M</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 3.7 恢复默认索引并将列保持为原表的相对位置
df_tmp = df_tmp.reset_index().reindex(df.columns, axis = 1)
df_tmp.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>EmployeeID</th>
      <th>birthdate_key</th>
      <th>age</th>
      <th>city_name</th>
      <th>department</th>
      <th>job_title</th>
      <th>gender</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1318</td>
      <td>1/3/1954</td>
      <td>61</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>CEO</td>
      <td>M</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1319</td>
      <td>1/3/1957</td>
      <td>58</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>VP Stores</td>
      <td>F</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1320</td>
      <td>1/2/1955</td>
      <td>60</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>Legal Counsel</td>
      <td>F</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1321</td>
      <td>1/2/1959</td>
      <td>56</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>VP Human Resources</td>
      <td>M</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1322</td>
      <td>1/9/1958</td>
      <td>57</td>
      <td>Vancouver</td>
      <td>Executive</td>
      <td>VP Finance</td>
      <td>M</td>
    </tr>
  </tbody>
</table>
</div>



### Ex2：巧克力数据集
现有一份关于巧克力评价的数据集：


```python
df = pd.read_csv('../data/chocolate.csv')
df.head(3)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Company</th>
      <th>Review\nDate</th>
      <th>Cocoa\nPercent</th>
      <th>Company\nLocation</th>
      <th>Rating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A. Morin</td>
      <td>2016</td>
      <td>63%</td>
      <td>France</td>
      <td>3.75</td>
    </tr>
    <tr>
      <th>1</th>
      <td>A. Morin</td>
      <td>2015</td>
      <td>70%</td>
      <td>France</td>
      <td>2.75</td>
    </tr>
    <tr>
      <th>2</th>
      <td>A. Morin</td>
      <td>2015</td>
      <td>70%</td>
      <td>France</td>
      <td>3.00</td>
    </tr>
  </tbody>
</table>
</div>



1. 把列索引名中的`\n`替换为空格。
2. 巧克力`Rating`评分为1至5，每0.25分一档，请选出2.75分及以下且可可含量`Cocoa Percent`高于中位数的样本。
3. 将`Review Date`和`Company Location`设为索引后，选出`Review Date`在2012年之后且`Company Location`不属于`France, Canada, Amsterdam, Belgium`的样本。


```python
# 1
df_2 = df.rename(columns = (lambda x:x.replace('\n', ' ')))
df_2.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Company</th>
      <th>Review Date</th>
      <th>Cocoa Percent</th>
      <th>Company Location</th>
      <th>Rating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A. Morin</td>
      <td>2016</td>
      <td>63%</td>
      <td>France</td>
      <td>3.75</td>
    </tr>
    <tr>
      <th>1</th>
      <td>A. Morin</td>
      <td>2015</td>
      <td>70%</td>
      <td>France</td>
      <td>2.75</td>
    </tr>
    <tr>
      <th>2</th>
      <td>A. Morin</td>
      <td>2015</td>
      <td>70%</td>
      <td>France</td>
      <td>3.00</td>
    </tr>
    <tr>
      <th>3</th>
      <td>A. Morin</td>
      <td>2015</td>
      <td>70%</td>
      <td>France</td>
      <td>3.50</td>
    </tr>
    <tr>
      <th>4</th>
      <td>A. Morin</td>
      <td>2015</td>
      <td>70%</td>
      <td>France</td>
      <td>3.50</td>
    </tr>
  </tbody>
</table>
</div>




```python
# 2

df_2['Cocoa Percent'] = df_2['Cocoa Percent'].str[:-1].astype('float')
df_2.loc[(df_2['Cocoa Percent']>df_2['Cocoa Percent'].median()) & (df_2.Rating<=2.75)].head()
```


```python
# 3
df_3 = df_2.set_index(['Review Date', 'Company Location']).sort_index(level = 0)
df_3.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Company</th>
      <th>Cocoa Percent</th>
      <th>Rating</th>
    </tr>
    <tr>
      <th>Review Date</th>
      <th>Company Location</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">2006</th>
      <th>Belgium</th>
      <td>Cote d' Or (Kraft)</td>
      <td>70.0</td>
      <td>1.00</td>
    </tr>
    <tr>
      <th>Belgium</th>
      <td>Dolfin (Belcolade)</td>
      <td>70.0</td>
      <td>1.50</td>
    </tr>
    <tr>
      <th>Belgium</th>
      <td>Neuhaus (Callebaut)</td>
      <td>73.0</td>
      <td>2.00</td>
    </tr>
    <tr>
      <th>Belgium</th>
      <td>Neuhaus (Callebaut)</td>
      <td>75.0</td>
      <td>2.75</td>
    </tr>
    <tr>
      <th>Belgium</th>
      <td>Neuhaus (Callebaut)</td>
      <td>71.0</td>
      <td>3.00</td>
    </tr>
  </tbody>
</table>
</div>




```python
idx = pd.IndexSlice
df_3.loc[idx[2012:, ~df_3.index.get_level_values(1).isin(['France', 'Canada', 'Amsterdam', 'Belgium'])], :].head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>Company</th>
      <th>Cocoa Percent</th>
      <th>Rating</th>
    </tr>
    <tr>
      <th>Review Date</th>
      <th>Company Location</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="5" valign="top">2012</th>
      <th>Australia</th>
      <td>Bahen &amp; Co.</td>
      <td>70.0</td>
      <td>3.00</td>
    </tr>
    <tr>
      <th>Australia</th>
      <td>Bahen &amp; Co.</td>
      <td>70.0</td>
      <td>2.50</td>
    </tr>
    <tr>
      <th>Australia</th>
      <td>Bahen &amp; Co.</td>
      <td>70.0</td>
      <td>2.50</td>
    </tr>
    <tr>
      <th>Australia</th>
      <td>Cravve</td>
      <td>75.0</td>
      <td>3.25</td>
    </tr>
    <tr>
      <th>Australia</th>
      <td>Cravve</td>
      <td>65.0</td>
      <td>3.25</td>
    </tr>
  </tbody>
</table>
</div>


